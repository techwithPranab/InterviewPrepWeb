Order,Question,Answer,Category,Tags,Code Example,References
1,"What is the difference between abstract class and interface in Java?","Abstract classes can have both abstract and concrete methods, constructors, instance variables, and access modifiers. Interfaces (before Java 8) could only have abstract methods and constants. From Java 8+, interfaces can have default and static methods. A class can extend only one abstract class but implement multiple interfaces. Use abstract classes for ""is-a"" relationships and interfaces for ""can-do"" relationships.","OOP Concepts","abstract-class, interface, inheritance","// Abstract class\nabstract class Animal {\n    protected String name;\n    \n    public Animal(String name) {\n        this.name = name;\n    }\n    \n    public void sleep() {\n        System.out.println(name + "" is sleeping"");\n    }\n    \n    public abstract void makeSound();\n}\n\n// Interface\ninterface Flyable {\n    void fly();\n    \n    default void land() {\n        System.out.println(""Landing safely"");\n    }\n}","Oracle Java Documentation, Effective Java"
2,"Explain method overloading and method overriding in Java.","Method Overloading: Multiple methods with same name but different parameters (compile-time polymorphism). Method Overriding: Child class provides specific implementation of parent class method (runtime polymorphism). Overloading uses different signatures, overriding uses same signature with @Override annotation.","OOP Concepts","overloading, overriding, polymorphism","// Method Overloading\nclass Calculator {\n    public int add(int a, int b) {\n        return a + b;\n    }\n    \n    public double add(double a, double b) {\n        return a + b;\n    }\n    \n    public int add(int a, int b, int c) {\n        return a + b + c;\n    }\n}\n\n// Method Overriding\nclass Animal {\n    public void makeSound() {\n        System.out.println(""Animal makes sound"");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(""Dog barks"");\n    }\n}","Oracle Java Tutorials"
3,"What are the access modifiers in Java and their scope?","Java has 4 access modifiers: public (accessible everywhere), protected (same package + subclasses), default/package-private (same package only), private (same class only). These control visibility and encapsulation in object-oriented design.","Core Concepts","access-modifiers, encapsulation, visibility","public class AccessModifierExample {\n    public String publicVar = ""Accessible everywhere"";\n    protected String protectedVar = ""Same package + subclasses"";\n    String defaultVar = ""Same package only"";\n    private String privateVar = ""Same class only"";\n    \n    public void accessTest() {\n        // All variables accessible within same class\n        System.out.println(publicVar);\n        System.out.println(protectedVar);\n        System.out.println(defaultVar);\n        System.out.println(privateVar);\n    }\n}","Oracle Java Documentation"
4,"Explain the concept of inheritance in Java.","Inheritance allows a class to inherit properties and methods from another class using 'extends' keyword. It promotes code reusability and establishes ""is-a"" relationship. Java supports single inheritance (one parent class) but multiple inheritance through interfaces. Child class can override parent methods and add new functionality.","OOP Concepts","inheritance, extends, is-a-relationship","class Vehicle {\n    protected String brand;\n    protected int speed;\n    \n    public Vehicle(String brand) {\n        this.brand = brand;\n    }\n    \n    public void start() {\n        System.out.println(brand + "" is starting"");\n    }\n}\n\nclass Car extends Vehicle {\n    private int doors;\n    \n    public Car(String brand, int doors) {\n        super(brand); // Call parent constructor\n        this.doors = doors;\n    }\n    \n    @Override\n    public void start() {\n        System.out.println(""Car "" + brand + "" is starting with key"");\n    }\n    \n    public void honk() {\n        System.out.println(""Car is honking"");\n    }\n}","Oracle Java Tutorials"
5,"What is encapsulation and how is it implemented in Java?","Encapsulation is the bundling of data (variables) and methods that operate on that data within a single unit (class), while hiding internal implementation details. Implemented using private variables and public getter/setter methods. It provides data security, maintainability, and flexibility.","OOP Concepts","encapsulation, getter-setter, data-hiding","public class BankAccount {\n    private double balance; // Private data\n    private String accountNumber;\n    \n    public BankAccount(String accountNumber, double initialBalance) {\n        this.accountNumber = accountNumber;\n        this.balance = initialBalance;\n    }\n    \n    // Public getter\n    public double getBalance() {\n        return balance;\n    }\n    \n    // Public methods for controlled access\n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n        }\n    }\n    \n    public boolean withdraw(double amount) {\n        if (amount > 0 && amount <= balance) {\n            balance -= amount;\n            return true;\n        }\n        return false;\n    }\n}","Oracle Java Documentation"
6,"Explain polymorphism in Java with examples.","Polymorphism means ""many forms"" - one interface, multiple implementations. Two types: Compile-time (method overloading) and Runtime (method overriding). Runtime polymorphism achieved through inheritance and interface implementation, allowing objects to be treated as instances of their parent type.","OOP Concepts","polymorphism, dynamic-binding, runtime","// Runtime Polymorphism Example\nclass Shape {\n    public void draw() {\n        System.out.println(""Drawing a shape"");\n    }\n    \n    public double getArea() {\n        return 0;\n    }\n}\n\nclass Circle extends Shape {\n    private double radius;\n    \n    public Circle(double radius) {\n        this.radius = radius;\n    }\n    \n    @Override\n    public void draw() {\n        System.out.println(""Drawing a circle"");\n    }\n    \n    @Override\n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\nclass Rectangle extends Shape {\n    private double width, height;\n    \n    public Rectangle(double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n    \n    @Override\n    public void draw() {\n        System.out.println(""Drawing a rectangle"");\n    }\n    \n    @Override\n    public double getArea() {\n        return width * height;\n    }\n}\n\n// Usage\nShape[] shapes = {new Circle(5), new Rectangle(4, 6)};\nfor (Shape shape : shapes) {\n    shape.draw(); // Polymorphic method call\n    System.out.println(""Area: "" + shape.getArea());\n}","Oracle Java Tutorials"
7,"What are the differences between String, StringBuilder, and StringBuffer?","String: Immutable, thread-safe, creates new object for each modification. StringBuilder: Mutable, not thread-safe, efficient for single-threaded string manipulation. StringBuffer: Mutable, thread-safe (synchronized), slightly slower than StringBuilder. Use String for few modifications, StringBuilder for many modifications in single thread, StringBuffer for many modifications in multi-threaded environment.","String Handling","string, stringbuilder, stringbuffer, immutable","// String - Immutable\nString str = ""Hello"";\nstr = str + "" World""; // Creates new String object\n\n// StringBuilder - Mutable, not thread-safe\nStringBuilder sb = new StringBuilder(""Hello"");\nsb.append("" World""); // Modifies existing buffer\nString result = sb.toString();\n\n// StringBuffer - Mutable, thread-safe\nStringBuffer sbf = new StringBuffer(""Hello"");\nsbf.append("" World""); // Synchronized methods\nString result2 = sbf.toString();\n\n// Performance comparison\nlong start = System.currentTimeMillis();\nString s = """";\nfor (int i = 0; i < 10000; i++) {\n    s += i; // Very slow - creates 10000 String objects\n}\nlong stringTime = System.currentTimeMillis() - start;\n\nstart = System.currentTimeMillis();\nStringBuilder sb2 = new StringBuilder();\nfor (int i = 0; i < 10000; i++) {\n    sb2.append(i); // Fast - modifies buffer\n}\nString result3 = sb2.toString();\nlong sbTime = System.currentTimeMillis() - start;","Oracle Java Documentation"
8,"Explain Java memory management and garbage collection.","Java memory is divided into Heap (objects), Stack (method calls, local variables), Method Area (class metadata), and PC Register. Garbage Collection automatically reclaims memory of unreferenced objects. GC algorithms include Serial, Parallel, G1, ZGC. Memory leaks can occur with static collections, listeners, and unclosed resources.","Memory Management","garbage-collection, heap, stack, memory-leaks","public class MemoryExample {\n    private static List<String> staticList = new ArrayList<>(); // Potential memory leak\n    \n    public void demonstrateMemory() {\n        // Stack memory - method local variables\n        int localVar = 10;\n        String localString = ""Hello"";\n        \n        // Heap memory - objects\n        List<String> list = new ArrayList<>();\n        for (int i = 0; i < 1000; i++) {\n            list.add(""Item "" + i);\n        }\n        \n        // Objects become eligible for GC when method ends\n        // unless referenced by static variables\n    }\n    \n    public void memoryLeak() {\n        // Adding to static collection - won't be garbage collected\n        staticList.add(""This might cause memory leak"");\n    }\n    \n    // Proper resource management\n    public void properResourceUsage() {\n        try (FileInputStream fis = new FileInputStream(""file.txt"")) {\n            // Use file\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        // File automatically closed due to try-with-resources\n    }\n}","Oracle Memory Management Guide"
9,"What are Java Collections and their hierarchy?","Java Collections Framework provides data structures and algorithms. Main interfaces: Collection (List, Set, Queue) and Map. List: ArrayList (resizable array), LinkedList (doubly-linked). Set: HashSet (hash table), TreeSet (sorted), LinkedHashSet (insertion order). Map: HashMap, TreeMap, LinkedHashMap. Queue: PriorityQueue, ArrayDeque.","Collections","collections, list, set, map, arraylist, hashmap","import java.util.*;\n\npublic class CollectionsExample {\n    public void demonstrateCollections() {\n        // List - allows duplicates, maintains order\n        List<String> list = new ArrayList<>();\n        list.add(""Apple"");\n        list.add(""Banana"");\n        list.add(""Apple""); // Duplicate allowed\n        \n        // Set - no duplicates\n        Set<String> set = new HashSet<>();\n        set.add(""Apple"");\n        set.add(""Banana"");\n        set.add(""Apple""); // Duplicate ignored\n        \n        // Map - key-value pairs\n        Map<String, Integer> map = new HashMap<>();\n        map.put(""Apple"", 10);\n        map.put(""Banana"", 20);\n        \n        // TreeSet - sorted set\n        Set<String> sortedSet = new TreeSet<>();\n        sortedSet.add(""Charlie"");\n        sortedSet.add(""Alpha"");\n        sortedSet.add(""Beta"");\n        // Output: [Alpha, Beta, Charlie]\n        \n        // LinkedHashMap - maintains insertion order\n        Map<String, Integer> orderedMap = new LinkedHashMap<>();\n        orderedMap.put(""First"", 1);\n        orderedMap.put(""Second"", 2);\n        orderedMap.put(""Third"", 3);\n    }\n}","Oracle Collections Tutorial"
10,"Explain exception handling in Java.","Exception handling manages runtime errors using try-catch-finally blocks. Two types: Checked exceptions (must be handled) and Unchecked exceptions (runtime). Keywords: try (code that might throw), catch (handle exception), finally (always executes), throw (manually throw), throws (declare exceptions). Custom exceptions extend Exception or RuntimeException.","Exception Handling","exceptions, try-catch, checked-unchecked, finally","public class ExceptionHandlingExample {\n    \n    // Method that throws checked exception\n    public void readFile(String filename) throws IOException {\n        FileReader file = new FileReader(filename);\n        // File operations\n        file.close();\n    }\n    \n    // Exception handling with try-catch-finally\n    public void handleExceptions() {\n        try {\n            int result = 10 / 0; // ArithmeticException\n            readFile(""nonexistent.txt""); // IOException\n        } catch (ArithmeticException e) {\n            System.out.println(""Cannot divide by zero: "" + e.getMessage());\n        } catch (IOException e) {\n            System.out.println(""File error: "" + e.getMessage());\n        } catch (Exception e) {\n            System.out.println(""General error: "" + e.getMessage());\n        } finally {\n            System.out.println(""This always executes"");\n        }\n    }\n    \n    // Custom exception\n    public class InvalidAgeException extends Exception {\n        public InvalidAgeException(String message) {\n            super(message);\n        }\n    }\n    \n    public void validateAge(int age) throws InvalidAgeException {\n        if (age < 0 || age > 150) {\n            throw new InvalidAgeException(""Invalid age: "" + age);\n        }\n    }\n}","Oracle Exception Tutorial"
11,"What is multithreading in Java and how is it implemented?","Multithreading allows concurrent execution of multiple threads. Implemented by extending Thread class or implementing Runnable interface. Thread states: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED. Synchronization prevents race conditions using synchronized keyword, locks, or concurrent collections.","Multithreading","threads, concurrency, synchronization, runnable","// Implementing Runnable interface\nclass MyTask implements Runnable {\n    private String taskName;\n    \n    public MyTask(String taskName) {\n        this.taskName = taskName;\n    }\n    \n    @Override\n    public void run() {\n        for (int i = 1; i <= 5; i++) {\n            System.out.println(taskName + "" - Count: "" + i);\n            try {\n                Thread.sleep(1000); // Sleep for 1 second\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n// Extending Thread class\nclass MyThread extends Thread {\n    private String threadName;\n    \n    public MyThread(String threadName) {\n        this.threadName = threadName;\n    }\n    \n    @Override\n    public void run() {\n        System.out.println(threadName + "" is running"");\n    }\n}\n\n// Synchronization example\nclass Counter {\n    private int count = 0;\n    \n    public synchronized void increment() {\n        count++;\n    }\n    \n    public int getCount() {\n        return count;\n    }\n}\n\n// Usage\npublic class ThreadExample {\n    public static void main(String[] args) {\n        // Using Runnable\n        Thread t1 = new Thread(new MyTask(""Task-1""));\n        Thread t2 = new Thread(new MyTask(""Task-2""));\n        \n        t1.start();\n        t2.start();\n        \n        // Using Thread class\n        MyThread t3 = new MyThread(""Thread-3"");\n        t3.start();\n    }\n}","Oracle Concurrency Tutorial"
12,"What are the differences between ArrayList and LinkedList?","ArrayList: Dynamic array, fast random access O(1), slow insertion/deletion in middle O(n), good for frequent access. LinkedList: Doubly-linked list, slow random access O(n), fast insertion/deletion O(1), implements List and Deque interfaces, good for frequent insertions/deletions.","Collections","arraylist, linkedlist, performance, data-structures","import java.util.*;\n\npublic class ListComparison {\n    public void comparePerformance() {\n        List<Integer> arrayList = new ArrayList<>();\n        List<Integer> linkedList = new LinkedList<>();\n        \n        // Adding elements - both O(1) at end\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 100000; i++) {\n            arrayList.add(i);\n        }\n        long arrayListAddTime = System.currentTimeMillis() - start;\n        \n        start = System.currentTimeMillis();\n        for (int i = 0; i < 100000; i++) {\n            linkedList.add(i);\n        }\n        long linkedListAddTime = System.currentTimeMillis() - start;\n        \n        // Random access - ArrayList O(1), LinkedList O(n)\n        start = System.currentTimeMillis();\n        for (int i = 0; i < 10000; i++) {\n            arrayList.get(i * 10);\n        }\n        long arrayListAccessTime = System.currentTimeMillis() - start;\n        \n        start = System.currentTimeMillis();\n        for (int i = 0; i < 10000; i++) {\n            linkedList.get(i * 10);\n        }\n        long linkedListAccessTime = System.currentTimeMillis() - start;\n        \n        // Insertion in middle\n        start = System.currentTimeMillis();\n        for (int i = 0; i < 1000; i++) {\n            arrayList.add(1000, i); // Insert at index 1000\n        }\n        long arrayListInsertTime = System.currentTimeMillis() - start;\n        \n        start = System.currentTimeMillis();\n        ListIterator<Integer> iterator = linkedList.listIterator(1000);\n        for (int i = 0; i < 1000; i++) {\n            iterator.add(i); // Insert at position\n        }\n        long linkedListInsertTime = System.currentTimeMillis() - start;\n        \n        System.out.println(""ArrayList - Add: "" + arrayListAddTime + ""ms, Access: "" + arrayListAccessTime + ""ms, Insert: "" + arrayListInsertTime + ""ms"");\n        System.out.println(""LinkedList - Add: "" + linkedListAddTime + ""ms, Access: "" + linkedListAccessTime + ""ms, Insert: "" + linkedListInsertTime + ""ms"");\n    }\n}","Oracle Collections Documentation"
13,"Explain the concept of Java generics.","Generics provide type safety at compile time by allowing classes and methods to operate on objects of various types while providing compile-time type checking. Benefits: Type safety, elimination of type casting, enabling generic algorithms. Syntax uses angle brackets <T> for type parameters. Supports wildcards (?, extends, super) for flexibility.","Generics","generics, type-safety, wildcards, parameterized-types","// Generic class\npublic class Box<T> {\n    private T content;\n    \n    public void setContent(T content) {\n        this.content = content;\n    }\n    \n    public T getContent() {\n        return content;\n    }\n}\n\n// Generic method\npublic class Utility {\n    public static <T> void swap(T[] array, int i, int j) {\n        T temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    \n    // Bounded type parameters\n    public static <T extends Number> double sum(List<T> numbers) {\n        double total = 0.0;\n        for (T number : numbers) {\n            total += number.doubleValue();\n        }\n        return total;\n    }\n}\n\n// Wildcards\npublic class WildcardExample {\n    // Upper bounded wildcard\n    public static double sumNumbers(List<? extends Number> numbers) {\n        double total = 0.0;\n        for (Number number : numbers) {\n            total += number.doubleValue();\n        }\n        return total;\n    }\n    \n    // Lower bounded wildcard\n    public static void addNumbers(List<? super Integer> numbers) {\n        numbers.add(1);\n        numbers.add(2);\n    }\n}\n\n// Usage\npublic class GenericExample {\n    public static void main(String[] args) {\n        Box<String> stringBox = new Box<>();\n        stringBox.setContent(""Hello"");\n        String str = stringBox.getContent(); // No casting needed\n        \n        Box<Integer> intBox = new Box<>();\n        intBox.setContent(42);\n        Integer num = intBox.getContent();\n        \n        // Generic method usage\n        String[] names = {""Alice"", ""Bob"", ""Charlie""};\n        Utility.swap(names, 0, 2);\n        \n        List<Integer> intList = Arrays.asList(1, 2, 3, 4, 5);\n        double sum = Utility.sum(intList);\n    }\n}","Oracle Generics Tutorial"
14,"What is the difference between == and equals() method in Java?","== operator: Compares references (memory addresses) for objects, values for primitives. equals() method: Compares actual content/state of objects, can be overridden for custom comparison logic. For String, equals() compares character sequence. Always override hashCode() when overriding equals().","Object Comparison","equals, hashcode, object-comparison, reference","public class ComparisonExample {\n    public static void main(String[] args) {\n        // String comparison\n        String str1 = new String(""Hello"");\n        String str2 = new String(""Hello"");\n        String str3 = ""Hello"";\n        String str4 = ""Hello"";\n        \n        System.out.println(str1 == str2);        // false (different objects)\n        System.out.println(str1.equals(str2));   // true (same content)\n        System.out.println(str3 == str4);        // true (string pool)\n        System.out.println(str3.equals(str4));   // true (same content)\n        \n        // Custom class comparison\n        Person p1 = new Person(""John"", 25);\n        Person p2 = new Person(""John"", 25);\n        Person p3 = p1;\n        \n        System.out.println(p1 == p2);      // false (different objects)\n        System.out.println(p1.equals(p2)); // true (if equals is overridden)\n        System.out.println(p1 == p3);      // true (same reference)\n    }\n}\n\nclass Person {\n    private String name;\n    private int age;\n    \n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj) return true;\n        if (obj == null || getClass() != obj.getClass()) return false;\n        \n        Person person = (Person) obj;\n        return age == person.age && Objects.equals(name, person.name);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(name, age);\n    }\n}","Oracle Object Methods Documentation"
15,"What are static variables and methods in Java?","Static members belong to the class rather than instances. Static variables: Shared among all instances, initialized once when class is first loaded, also called class variables. Static methods: Can be called without creating instance, cannot access instance variables/methods directly, commonly used for utility functions.","Static Members","static, class-variables, utility-methods, memory","public class StaticExample {\n    // Static variable - shared among all instances\n    private static int objectCount = 0;\n    private static final String COMPANY_NAME = ""TechCorp"";\n    \n    // Instance variable\n    private String name;\n    \n    public StaticExample(String name) {\n        this.name = name;\n        objectCount++; // Increment for each new instance\n    }\n    \n    // Static method\n    public static int getObjectCount() {\n        return objectCount;\n    }\n    \n    // Static utility method\n    public static boolean isValidEmail(String email) {\n        return email != null && email.contains(""@"");\n    }\n    \n    // Instance method\n    public void displayInfo() {\n        System.out.println(""Name: "" + name);\n        System.out.println(""Company: "" + COMPANY_NAME);\n        System.out.println(""Total objects: "" + objectCount);\n    }\n    \n    // Static block - executed once when class is loaded\n    static {\n        System.out.println(""StaticExample class is being loaded"");\n        // Initialize static variables if needed\n    }\n}\n\n// Usage\npublic class StaticDemo {\n    public static void main(String[] args) {\n        // Call static method without creating instance\n        System.out.println(""Object count: "" + StaticExample.getObjectCount());\n        \n        StaticExample obj1 = new StaticExample(""Alice"");\n        StaticExample obj2 = new StaticExample(""Bob"");\n        \n        System.out.println(""Object count: "" + StaticExample.getObjectCount());\n        \n        // Static utility method\n        boolean valid = StaticExample.isValidEmail(""user@example.com"");\n    }\n}","Oracle Static Members Guide"
16,"Explain the concept of final keyword in Java.","Final keyword has different meanings in different contexts: Final variables - constants, cannot be reassigned. Final methods - cannot be overridden by subclasses. Final classes - cannot be extended (e.g., String, Integer). Final parameters - cannot be modified within method. Blank final variables must be initialized in constructor.","Keywords","final, constants, inheritance, immutability","// Final class - cannot be extended\nfinal class ImmutableClass {\n    private final String value;\n    private final List<String> list;\n    \n    public ImmutableClass(String value, List<String> list) {\n        this.value = value;\n        this.list = new ArrayList<>(list); // Defensive copy\n    }\n    \n    public String getValue() {\n        return value;\n    }\n    \n    public List<String> getList() {\n        return new ArrayList<>(list); // Return copy to maintain immutability\n    }\n}\n\nclass Parent {\n    // Final method - cannot be overridden\n    public final void displayMessage() {\n        System.out.println(""This method cannot be overridden"");\n    }\n    \n    public void regularMethod() {\n        System.out.println(""This can be overridden"");\n    }\n}\n\nclass Child extends Parent {\n    // This would cause compilation error\n    // public void displayMessage() { }\n    \n    @Override\n    public void regularMethod() {\n        System.out.println(""Overridden method"");\n    }\n}\n\npublic class FinalExample {\n    // Final static variable - compile-time constant\n    public static final String CONSTANT = ""UNCHANGEABLE"";\n    \n    // Final instance variable - runtime constant\n    private final String id;\n    \n    public FinalExample(String id) {\n        this.id = id; // Must be initialized\n    }\n    \n    public void processData(final List<String> data) {\n        // data = new ArrayList<>(); // Compilation error\n        data.add(""item""); // OK - modifying content, not reference\n        \n        final String localVar = ""local"";\n        // localVar = ""new value""; // Compilation error\n    }\n}","Oracle Final Keyword Documentation"
17,"What is the difference between HashMap and HashTable?","HashMap: Not synchronized (not thread-safe), allows null key and values, introduced in JDK 1.2, better performance in single-threaded environment. HashTable: Synchronized (thread-safe), doesn't allow null keys or values, legacy class from JDK 1.0, slower due to synchronization overhead. For thread-safety, prefer ConcurrentHashMap over HashTable.","Collections","hashmap, hashtable, synchronization, thread-safety","import java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class MapComparison {\n    public void compareHashMapAndHashTable() {\n        // HashMap - not thread-safe, allows nulls\n        HashMap<String, Integer> hashMap = new HashMap<>();\n        hashMap.put(""key1"", 1);\n        hashMap.put(""key2"", 2);\n        hashMap.put(null, 3);      // Allowed\n        hashMap.put(""key3"", null); // Allowed\n        \n        // HashTable - thread-safe, no nulls\n        Hashtable<String, Integer> hashTable = new Hashtable<>();\n        hashTable.put(""key1"", 1);\n        hashTable.put(""key2"", 2);\n        // hashTable.put(null, 3);      // NullPointerException\n        // hashTable.put(""key3"", null); // NullPointerException\n        \n        // ConcurrentHashMap - modern thread-safe alternative\n        ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();\n        concurrentMap.put(""key1"", 1);\n        concurrentMap.put(""key2"", 2);\n        // concurrentMap.put(null, 3);      // NullPointerException\n        // concurrentMap.put(""key3"", null); // NullPointerException\n        \n        // Performance test (simplified)\n        Map<String, Integer> map = new HashMap<>(); // Or Hashtable for comparison\n        \n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 100000; i++) {\n            map.put(""key"" + i, i);\n        }\n        long putTime = System.currentTimeMillis() - start;\n        \n        start = System.currentTimeMillis();\n        for (int i = 0; i < 100000; i++) {\n            map.get(""key"" + i);\n        }\n        long getTime = System.currentTimeMillis() - start;\n        \n        System.out.println(""Put time: "" + putTime + ""ms, Get time: "" + getTime + ""ms"");\n    }\n    \n    // Thread-safe operations with different approaches\n    public void threadSafeOperations() {\n        // Synchronized wrapper\n        Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());\n        \n        // Manual synchronization\n        Map<String, Integer> manualSyncMap = new HashMap<>();\n        synchronized (manualSyncMap) {\n            manualSyncMap.put(""key"", 1);\n            manualSyncMap.get(""key"");\n        }\n    }\n}","Oracle Collections Tutorial"
18,"Explain constructors in Java and their types.","Constructors are special methods used to initialize objects. Types: Default constructor (no parameters, provided by compiler if no constructor defined), Parameterized constructor (with parameters), Copy constructor (copies another object). Constructor chaining using this() and super(). Constructors cannot be inherited but can be called from subclass.","Constructors","constructors, initialization, this, super, chaining","public class Person {\n    private String name;\n    private int age;\n    private String email;\n    \n    // Default constructor\n    public Person() {\n        this(""Unknown"", 0); // Constructor chaining\n    }\n    \n    // Parameterized constructor\n    public Person(String name, int age) {\n        this.name = name;\n        this.age = age;\n        this.email = ""not provided"";\n    }\n    \n    // Another parameterized constructor\n    public Person(String name, int age, String email) {\n        this(name, age); // Call another constructor\n        this.email = email;\n    }\n    \n    // Copy constructor (Java doesn't have built-in copy constructor)\n    public Person(Person other) {\n        this.name = other.name;\n        this.age = other.age;\n        this.email = other.email;\n    }\n    \n    public void displayInfo() {\n        System.out.println(""Name: "" + name + "", Age: "" + age + "", Email: "" + email);\n    }\n}\n\n// Inheritance and constructor chaining\nclass Employee extends Person {\n    private String department;\n    private double salary;\n    \n    public Employee() {\n        super(); // Call parent default constructor\n        this.department = ""General"";\n        this.salary = 0.0;\n    }\n    \n    public Employee(String name, int age, String department, double salary) {\n        super(name, age); // Call parent parameterized constructor\n        this.department = department;\n        this.salary = salary;\n    }\n    \n    @Override\n    public void displayInfo() {\n        super.displayInfo();\n        System.out.println(""Department: "" + department + "", Salary: "" + salary);\n    }\n}\n\n// Usage\npublic class ConstructorExample {\n    public static void main(String[] args) {\n        Person p1 = new Person(); // Default constructor\n        Person p2 = new Person(""Alice"", 30); // Parameterized constructor\n        Person p3 = new Person(""Bob"", 25, ""bob@email.com""); // Full constructor\n        Person p4 = new Person(p2); // Copy constructor\n        \n        Employee emp = new Employee(""Charlie"", 35, ""IT"", 75000);\n        emp.displayInfo();\n    }\n}","Oracle Constructor Documentation"
19,"What is the difference between checked and unchecked exceptions?","Checked exceptions: Must be handled at compile time using try-catch or throws declaration (IOException, SQLException). Compiler enforces handling. Unchecked exceptions: Runtime exceptions that don't require explicit handling (NullPointerException, ArrayIndexOutOfBoundsException). Inherit from RuntimeException.","Exception Handling","checked-exceptions, unchecked-exceptions, compile-time, runtime","import java.io.*;\nimport java.sql.*;\n\npublic class ExceptionTypesExample {\n    \n    // Method with checked exceptions - must declare or handle\n    public void readFileWithChecked(String filename) throws IOException, FileNotFoundException {\n        FileReader file = new FileReader(filename); // Checked exception\n        BufferedReader reader = new BufferedReader(file);\n        String line = reader.readLine();\n        reader.close();\n    }\n    \n    // Method with proper exception handling\n    public void readFileWithHandling(String filename) {\n        try {\n            FileReader file = new FileReader(filename);\n            BufferedReader reader = new BufferedReader(file);\n            String line = reader.readLine();\n            reader.close();\n        } catch (FileNotFoundException e) {\n            System.out.println(""File not found: "" + e.getMessage());\n        } catch (IOException e) {\n            System.out.println(""IO error: "" + e.getMessage());\n        }\n    }\n    \n    // Methods that can throw unchecked exceptions\n    public void uncheckedExceptionExamples() {\n        // NullPointerException - unchecked\n        String str = null;\n        // int length = str.length(); // Will throw NPE at runtime\n        \n        // ArrayIndexOutOfBoundsException - unchecked\n        int[] array = {1, 2, 3};\n        // int value = array[5]; // Will throw AIOOBE at runtime\n        \n        // IllegalArgumentException - unchecked\n        // Thread.sleep(-1); // Will throw IAE at runtime\n        \n        // Better approach - validate before use\n        if (str != null) {\n            int length = str.length();\n        }\n        \n        if (array.length > 5) {\n            int value = array[5];\n        }\n    }\n    \n    // Custom checked exception\n    public class InvalidAccountException extends Exception {\n        public InvalidAccountException(String message) {\n            super(message);\n        }\n    }\n    \n    // Custom unchecked exception\n    public class InsufficientFundsException extends RuntimeException {\n        public InsufficientFundsException(String message) {\n            super(message);\n        }\n    }\n    \n    // Using custom exceptions\n    public void withdraw(double amount, double balance) throws InvalidAccountException {\n        if (balance < 0) {\n            throw new InvalidAccountException(""Account balance cannot be negative"");\n        }\n        \n        if (amount > balance) {\n            throw new InsufficientFundsException(""Insufficient funds for withdrawal"");\n        }\n        \n        // Process withdrawal\n    }\n}","Oracle Exception Handling Guide"
20,"Explain the concept of autoboxing and unboxing in Java.","Autoboxing: Automatic conversion of primitive data types to their corresponding wrapper class objects. Unboxing: Automatic conversion of wrapper class objects to their corresponding primitive types. Introduced in Java 5. Happens automatically in assignments, method calls, and expressions. Can cause performance overhead and NullPointerException.","Autoboxing","autoboxing, unboxing, wrapper-classes, primitives","import java.util.*;\n\npublic class AutoboxingExample {\n    public void demonstrateAutoboxing() {\n        // Autoboxing - primitive to wrapper\n        int primitive = 10;\n        Integer wrapper = primitive; // Autoboxing: int to Integer\n        \n        // Unboxing - wrapper to primitive\n        Integer wrapperObj = new Integer(20);\n        int primitiveValue = wrapperObj; // Unboxing: Integer to int\n        \n        // Autoboxing in collections\n        List<Integer> list = new ArrayList<>();\n        list.add(30); // Autoboxing: int to Integer\n        list.add(40); // Autoboxing: int to Integer\n        \n        // Unboxing from collections\n        int value = list.get(0); // Unboxing: Integer to int\n        \n        // Autoboxing in method calls\n        printInteger(50); // Autoboxing: int to Integer\n        int result = getInteger(); // Unboxing: Integer to int\n        \n        // Arithmetic operations with mixed types\n        Integer a = 100;\n        Integer b = 200;\n        int sum = a + b; // Unboxing both, then autoboxing result\n        \n        // Comparison pitfalls\n        Integer x = 127;\n        Integer y = 127;\n        System.out.println(x == y); // true (Integer cache -128 to 127)\n        \n        Integer m = 128;\n        Integer n = 128;\n        System.out.println(m == n); // false (different objects)\n        System.out.println(m.equals(n)); // true (content comparison)\n    }\n    \n    public void printInteger(Integer num) {\n        System.out.println(""Integer value: "" + num);\n    }\n    \n    public Integer getInteger() {\n        return 42; // Autoboxing: int to Integer\n    }\n    \n    // Performance impact demonstration\n    public void performanceComparison() {\n        // Using primitives - faster\n        long start = System.currentTimeMillis();\n        long sum = 0;\n        for (int i = 0; i < 1000000; i++) {\n            sum += i;\n        }\n        long primitiveTime = System.currentTimeMillis() - start;\n        \n        // Using wrappers - slower due to autoboxing/unboxing\n        start = System.currentTimeMillis();\n        Long wrapperSum = 0L;\n        for (Integer i = 0; i < 1000000; i++) { // Autoboxing in loop\n            wrapperSum += i; // Unboxing i, autoboxing result\n        }\n        long wrapperTime = System.currentTimeMillis() - start;\n        \n        System.out.println(""Primitive time: "" + primitiveTime + ""ms"");\n        System.out.println(""Wrapper time: "" + wrapperTime + ""ms"");\n    }\n    \n    // NullPointerException risk\n    public void nullPointerRisk() {\n        Integer nullInteger = null;\n        try {\n            int value = nullInteger; // NullPointerException during unboxing\n        } catch (NullPointerException e) {\n            System.out.println(""NPE during unboxing: "" + e.getMessage());\n        }\n        \n        // Safe approach\n        if (nullInteger != null) {\n            int safeValue = nullInteger;\n        }\n    }\n}","Oracle Autoboxing Documentation"
